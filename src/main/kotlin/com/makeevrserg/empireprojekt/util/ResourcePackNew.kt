package com.makeevrserg.empireprojekt.util

import com.google.gson.*
import com.makeevrserg.empireprojekt.EmpirePlugin
import com.makeevrserg.empireprojekt.items.EmpireItems
import org.apache.commons.lang.StringEscapeUtils
import java.io.*
import java.lang.NumberFormatException
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream


class ResourcePackNew {

    private val plugin = EmpirePlugin.instance
    private fun setPrettyString(file: JsonObject): String {
        return GsonBuilder().setPrettyPrinting().create().toJson(file)
    }

    private fun setPrettyString(line: String): String {
        val file = JsonParser().parse(line).asJsonObject
        return setPrettyString(file)
    }

    private fun getMinecraftModelsPath(): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + "minecraft" +
                File.separator + "models" +
                File.separator + "item"
    }

    private fun getMinecraftModelPath(material: String): String {
        return getMinecraftModelsPath() + File.separator + material.lowercase() + ".json"
    }

    private fun getAutoGeneratedModelPath(namespace: String, item: String): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + namespace +
                File.separator + "models" +
                File.separator + "auto_generated" +
                File.separator + item + ".json"
    }

    private fun getAutoGeneratedModelsPath(namespace: String): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + namespace +
                File.separator + "models" +
                File.separator + "auto_generated"
    }

    data class Provider(
        val type: String?,
        val file: String,
        val shift: List<Double>?,
        val size: Double?,
        val oversample: Int?,
        val chars: List<String>?,
        val height: Int?,
        val ascent: Int?
    )

    data class Fonts(
        val providers: List<Provider>
    )

    private fun generateFont() {
        val file =
            File(plugin.dataFolder.toString() + File.separator + "pack" + File.separator + "assets" + File.separator + "minecraft" + File.separator + "font" + File.separator + "default.json")
        val providers: MutableList<Provider> = mutableListOf()
        val defaultJson =
            JsonParser().parse(InputStreamReader(plugin.getResource("rpFiles/default.json")!!).readText()).asJsonObject
        providers.add(Gson().fromJson(defaultJson, Fonts::class.java).providers[0])
        for (font in EmpirePlugin.empireFontImages.fontsInfo.keys) {
            val fontInfo = EmpirePlugin.empireFontImages.fontsInfo[font]!!
            val provider = Provider(
                "bitmap",
                "${fontInfo.namespace}:${fontInfo.path}",
                null, null, null,
                listOf(StringEscapeUtils.escapeJava(fontInfo.chars)),
                fontInfo.height, fontInfo.ascent
            )
            providers.add(provider)
        }
        val json = Gson().toJson(Fonts(providers))
        file.writeText(setPrettyString(JsonParser().parse(json).asJsonObject).replace("\\\\", "\\"))
    }

    private fun generateSounds() {
        val map = EmpirePlugin.empireSounds.getSounds()
        val namespace = EmpirePlugin.empireSounds.getNamespace()
        val file = File(
            plugin.dataFolder,
            "pack${File.separator}assets${File.separator}${namespace}${File.separator}sounds.json"
        )
        val musicFileObj = JsonObject()
        for (soundID in map.keys) {
            val musicObj = JsonObject()
            val sounds = JsonArray()
            for (sound in map[soundID]!!)
                sounds.add("$namespace:$sound")
            musicObj.add("sounds", sounds)
            musicFileObj.add(soundID, musicObj)
        }
        file.writeText(setPrettyString(musicFileObj))
    }


    data class Model(
        var parent: String,
        val textures: Textures,
        var overrides: MutableList<Override>?,
        var gui_light: String?,
        var display: JsonObject?

    )

    data class Override(
        val model: String,
        val predicate: Predicate
    )

    data class Predicate(

        val custom_model_data: Int,
        val blocking: Int?,
        val pulling: Int?,
        val pull: Double?
    )

    data class Textures(
        var layer0: String?,
        val particle: String?
    )


    private fun clearItems() {
        for (file in File(getMinecraftModelsPath()).listFiles()) {
            if ("json" !in file.extension)
                continue
            if (file.name.contains("bow") || file.name.contains("shield")) {
                file.delete()
                continue
            }
            val jsonFile = JsonParser().parse(file.reader()).asJsonObject
            jsonFile.remove("overrides")
            file.writeText(setPrettyString(jsonFile))
        }
        File(getMinecraftModelPath("bow")).writeText(InputStreamReader(plugin.getResource("rpFiles/bow.json")!!).readText())
        File(getMinecraftModelPath("shield")).writeText(InputStreamReader(plugin.getResource("rpFiles/shield.json")!!).readText())
        File(getMinecraftModelPath("shield_blocking")).writeText(InputStreamReader(plugin.getResource("rpFiles/shield.json")!!).readText())
    }


    private fun generateMinecraftModel(file: File, item: EmpireItems.ItemInfo, model: Model) {
        val predicate = Predicate(item.customModelData, null, null, null)
        val override = Override("${item.namespace}:${item.model_path ?: ("auto_generated/" + item.id)}", predicate)
        model.overrides!!.add(override)
        file.writeText(setPrettyString(Gson().toJson(model)))
    }

    private fun generateMinecraftBowModel(file: File, item: EmpireItems.ItemInfo, model: Model) {
        model.overrides!!.add(
            Override(
                "${item.namespace}:auto_generated/${item.id}",
                Predicate(item.customModelData, null, 0, null)
            )
        )
        model.overrides!!.add(
            Override(
                "${item.namespace}:auto_generated/${item.id}_0",
                Predicate(item.customModelData, null, 1, null)
            )
        )
        model.overrides!!.add(
            Override(
                "${item.namespace}:auto_generated/${item.id}_1",
                Predicate(item.customModelData, null, 1, 0.65)
            )
        )
        model.overrides!!.add(
            Override(
                "${item.namespace}:auto_generated/${item.id}_2",
                Predicate(item.customModelData, null, 1, 0.9)
            )
        )

        file.writeText(setPrettyString(Gson().toJson(model)))
    }

    private fun generateMinecraftShieldModel(file: File, item: EmpireItems.ItemInfo, model: Model) {
        for (i in 0..1)
            model.overrides!!.add(
                Override(
                    "${item.namespace}:${item.model_path ?: ("auto_generated/" + item.id)}",
                    Predicate(item.customModelData, i, null, null)
                )
            )
        file.writeText(setPrettyString(Gson().toJson(model)))
    }

    private fun generateAutoGenerateModel(file: File, item: EmpireItems.ItemInfo, model: Model) {
        if (!file.exists())
            file.createNewFile()
        model.overrides = null
        model.display = null
        model.gui_light = null
        if (item.material.equals("bow", ignoreCase = true)) {
            model.parent = "item/base/bow"
            try {
                val code = file.nameWithoutExtension[file.nameWithoutExtension.length - 1].toString().toInt()
                model.textures.layer0 = "${item.namespace}:${item.texture_path}_${code}"
            } catch (e: NumberFormatException) {
                model.textures.layer0 = "${item.namespace}:${item.texture_path}"
            }
        } else
            model.textures.layer0 = "${item.namespace}:${item.texture_path}"
        file.writeText(setPrettyString(Gson().toJson(model)))
    }


    private fun generateItems() {
        val items = EmpirePlugin.empireItems.itemsInfo
        for (item in items) {
            val filePath = getMinecraftModelPath(item.material)
            val minecraftModelFile = File(filePath)
            if (!minecraftModelFile.exists()) {
                println(EmpirePlugin.translations.NOT_EXIST_FILE + " ${item.material.lowercase()}.json")
                continue
            }
            val fileText = InputStreamReader(minecraftModelFile.inputStream()).readText()
            val jsonObject = JsonParser().parse(fileText).asJsonObject
            val model: Model = Gson().fromJson(jsonObject, Model::class.java)
            if (model.overrides == null)
                model.overrides = mutableListOf()
            when {
                item.material.equals("bow", ignoreCase = true) -> {
                    generateMinecraftBowModel(minecraftModelFile, item, model)
                    generateAutoGenerateModel(File(getAutoGeneratedModelPath(item.namespace, item.id)), item, model)
                    for (i in 0..2)
                        generateAutoGenerateModel(
                            File(getAutoGeneratedModelPath(item.namespace, "${item.id}_$i")),
                            item,
                            model
                        )
                }
                item.material.equals("shield", ignoreCase = true) -> {

                    generateMinecraftShieldModel(minecraftModelFile, item, model)

                }
                else -> {
                    generateMinecraftModel(minecraftModelFile, item, model)
                    generateAutoGenerateModel(File(getAutoGeneratedModelPath(item.namespace, item.id)), item, model)
                }
            }


        }
    }

    init {
        println(EmpirePlugin.translations.ZIP_ITEMS)
        clearItems()
        generateItems()
        println(EmpirePlugin.translations.ZIP_FONTS)
        generateFont()
        println(EmpirePlugin.translations.ZIP_SOUND)
        generateSounds()
        //fixCustomModelDataOrder()
    }


    companion object {

        fun zipAll(folderPath: String, outputFilePath: String): Boolean {
            val fos = FileOutputStream(outputFilePath)
            val zipOut = ZipOutputStream(fos)
            try {
                var fileToZip = File(folderPath + File.separator + "assets")
                zipFile(fileToZip, fileToZip.name, zipOut)
                fileToZip = File(folderPath + File.separator + "pack.mcmeta")
                zipFile(fileToZip, fileToZip.name, zipOut)
                fileToZip = File(folderPath + File.separator + "pack.png")
                zipFile(fileToZip, fileToZip.name, zipOut)

                zipOut.close()
                fos.close()
                return true
            } catch (e: IOException) {
                return false
            } finally {
                zipOut.close()
                fos.close()
            }
        }

        @Throws(IOException::class)
        private fun zipFile(
            fileToZip: File,
            fileName: String,
            zipOut: ZipOutputStream
        ) {
            if (fileToZip.isHidden) {
                return
            }
            if (fileToZip.isDirectory) {
                if (fileName.endsWith("/")) {
                    zipOut.putNextEntry(ZipEntry(fileName))
                    zipOut.closeEntry()
                } else {
                    zipOut.putNextEntry(ZipEntry("$fileName/"))
                    zipOut.closeEntry()
                }
                val children = fileToZip.listFiles()
                for (childFile in children) {
                    zipFile(childFile, fileName + "/" + childFile.name, zipOut)
                }
                return
            }
            val fis = FileInputStream(fileToZip)
            val zipEntry = ZipEntry(fileName)
            zipOut.putNextEntry(zipEntry)
            val bytes = ByteArray(1024)
            var length: Int
            while (fis.read(bytes).also { length = it } >= 0) {
                zipOut.write(bytes, 0, length)
            }
            fis.close()

        }
    }
}