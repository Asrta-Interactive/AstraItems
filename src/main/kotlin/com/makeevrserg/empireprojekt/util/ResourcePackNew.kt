package com.makeevrserg.empireprojekt.util

import com.google.gson.*
import com.makeevrserg.empireprojekt.EmpirePlugin
import com.makeevrserg.empireprojekt.events.blocks.MushroomBlockApi
import com.makeevrserg.empireprojekt.items.data.EmpireItem
import org.apache.commons.lang.StringEscapeUtils
import org.bukkit.Instrument
import java.io.*
import java.lang.NumberFormatException
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream


class ResourcePackNew {

    private val plugin = EmpirePlugin.instance
    private fun setPrettyString(file: JsonObject): String {
        return GsonBuilder().setPrettyPrinting().create().toJson(file)
    }

    private fun setPrettyString(line: String): String {
        val file = JsonParser().parse(line).asJsonObject
        return setPrettyString(file)
    }

    private fun getMinecraftItemModelsPath(): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + "minecraft" +
                File.separator + "models" +
                File.separator + "item"
    }

    private fun getMinecraftPath(): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + "minecraft" + File.separator
    }

    private fun getMinecraftBlockModelsPath(): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + "minecraft" +
                File.separator + "models" +
                File.separator + "block" + File.separator
    }

    private fun getMinecraftItemModelPath(material: String): String {
        return getMinecraftItemModelsPath() + File.separator + material.lowercase() + ".json"
    }

    private fun getAutoGeneratedModelPath(namespace: String, item: String): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + namespace +
                File.separator + "models" +
                File.separator + "auto_generated" +
                File.separator + item + ".json"
    }

    private fun getAutoGeneratedModelsPath(namespace: String): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + namespace +
                File.separator + "models" +
                File.separator + "auto_generated"
    }

    data class Provider(
        val type: String?,
        val file: String,
        val shift: List<Double>?,
        val size: Double?,
        val oversample: Int?,
        val chars: List<String>?,
        val height: Int?,
        val ascent: Int?
    )

    data class Fonts(
        val providers: List<Provider>
    )

    private fun generateFont() {
        val file =
            File(plugin.dataFolder.toString() + File.separator + "pack" + File.separator + "assets" + File.separator + "minecraft" + File.separator + "font" + File.separator + "default.json")
        val providers: MutableList<Provider> = mutableListOf()
        val defaultJson =
            JsonParser().parse(InputStreamReader(plugin.getResource("rpFiles/default.json")!!).readText()).asJsonObject
        providers.add(Gson().fromJson(defaultJson, Fonts::class.java).providers[0])
        for (font in EmpirePlugin.empireFonts._fontInfoValueById.keys) {
            val fontInfo = EmpirePlugin.empireFonts._fontInfoValueById[font]!!
            val provider = Provider(
                "bitmap",
                "${fontInfo.path}",
                null, null, null,
                listOf(StringEscapeUtils.escapeJava(fontInfo.chars)),
                fontInfo.height,fontInfo.ascent
            )
            providers.add(provider)
        }
        val json = Gson().toJson(Fonts(providers))
        file.writeText(setPrettyString(JsonParser().parse(json).asJsonObject).replace("\\\\", "\\"))
    }

    private fun generateSounds() {


        val file = File(
            plugin.dataFolder,
            "pack${File.separator}assets${File.separator}empire_items${File.separator}sounds.json"
        )
        val musicFileObj = JsonObject()
        for (soundID in EmpirePlugin.empireSounds.soundByID.keys) {
            val musicObj = JsonObject()
            val sounds = JsonArray()
            for (sound in EmpirePlugin.empireSounds.soundByID[soundID]?.sounds?: mutableListOf())
            sounds.add("${sound}")
            musicObj.add("sounds", sounds)
            musicFileObj.add(soundID, musicObj)
        }
        file.writeText(setPrettyString(musicFileObj))
    }


    data class Model(
        var parent: String,
        var textures: Textures,
        var overrides: MutableList<Override>?,
        var gui_light: String?,
        var display: JsonObject?
    ) {
        public fun sort() {
            overrides ?: return
            overrides?.sortBy { it.predicate.custom_model_data }
        }
    }

    data class Override(
        val model: String,
        val predicate: Predicate
    )

    data class Predicate(

        val custom_model_data: Int,
        val blocking: Int?,
        val pulling: Int?,
        val pull: Double?
    )

    data class Textures(
        var layer0: String?,
        var all: String?,
        var particle: String?
    )


    private fun clearItems() {
        for (file in File(getMinecraftItemModelsPath()).listFiles()) {
            if ("json" !in file.extension)
                continue
            if (file.name.contains("bow") || file.name.contains("shield")) {
                file.delete()
                continue
            }
            val jsonFile = JsonParser().parse(file.reader()).asJsonObject
            jsonFile.remove("overrides")
            file.writeText(setPrettyString(jsonFile))
        }
        File(getMinecraftItemModelPath("bow")).writeText(InputStreamReader(plugin.getResource("rpFiles/bow.json")!!).readText())
        File(getMinecraftItemModelPath("shield")).writeText(InputStreamReader(plugin.getResource("rpFiles/shield.json")!!).readText())
        File(getMinecraftItemModelPath("shield_blocking")).writeText(InputStreamReader(plugin.getResource("rpFiles/shield.json")!!).readText())
    }


    private fun generateMinecraftModel(file: File, item: EmpireItem, model: Model) {
        val predicate = Predicate(item.customModelData, null, null, null)

        val override = Override("${item.namespace}:${item.modelPath ?: ("auto_generated/" + item.id)}", predicate)
        model.overrides!!.add(override)
        file.writeText(setPrettyString(Gson().toJson(model)))
    }

    private fun generateMinecraftBowModel(file: File, item: EmpireItem, model: Model) {
        model.overrides!!.add(
            Override(
                "${item.namespace}:auto_generated/${item.id}",
                Predicate(item.customModelData, null, 0, null)
            )
        )
        model.overrides!!.add(
            Override(
                "${item.namespace}:auto_generated/${item.id}_0",
                Predicate(item.customModelData, null, 1, null)
            )
        )
        model.overrides!!.add(
            Override(
                "${item.namespace}:auto_generated/${item.id}_1",
                Predicate(item.customModelData, null, 1, 0.65)
            )
        )
        model.overrides!!.add(
            Override(
                "${item.namespace}:auto_generated/${item.id}_2",
                Predicate(item.customModelData, null, 1, 0.9)
            )
        )

        file.writeText(setPrettyString(Gson().toJson(model)))
    }

    private fun generateMinecraftShieldModel(file: File, item: EmpireItem, model: Model) {
        for (i in 0..1)
            model.overrides!!.add(
                Override(
                    "${item.namespace}:${item.modelPath ?: ("auto_generated/" + item.id)}",
                    Predicate(item.customModelData, i, null, null)
                )
            )
        file.writeText(setPrettyString(Gson().toJson(model)))
    }

    private fun generateAutoGenerateModel(file: File, item: EmpireItem, model: Model) {
        if (!file.exists())
            file.createNewFile()
        model.overrides = null
        model.display = null
        model.gui_light = null
        if (item.material.equals("bow", ignoreCase = true)) {
            model.parent = "item/base/bow"
            try {
                val code = file.nameWithoutExtension[file.nameWithoutExtension.length - 1].toString().toInt()
                model.textures.layer0 = "${item.namespace}:${item.texturePath}_${code}"
            } catch (e: NumberFormatException) {
                model.textures.layer0 = "${item.namespace}:${item.texturePath}"
            }
        } else if (item.block != null) {
            model.parent = "block/base/block_real"
            model.textures = Textures(null, null, null)
            model.textures.all = "${item.namespace}:${item.texturePath}"
            model.textures.particle = "${item.namespace}:${item.texturePath}"
        } else
            model.textures.layer0 = "${item.namespace}:${item.texturePath}"
        file.writeText(setPrettyString(Gson().toJson(model)))
    }


    private fun generateItems() {
        val items = EmpirePlugin.empireItems.itemsInfo
        for (item in items) {
            val filePath = getMinecraftItemModelPath(item.material)
            val minecraftModelFile = File(filePath)
            if (!minecraftModelFile.exists()) {
                println(EmpirePlugin.translations.NOT_EXIST_FILE + " ${item.material.lowercase()}.json")
                continue
            }
            val fileText = InputStreamReader(minecraftModelFile.inputStream()).readText()
            val jsonObject = JsonParser().parse(fileText).asJsonObject
            val model: Model = Gson().fromJson(jsonObject, Model::class.java)
            if (model.overrides == null)
                model.overrides = mutableListOf()
            when {
                item.material.equals("bow", ignoreCase = true) -> {
                    generateMinecraftBowModel(minecraftModelFile, item, model)
                    generateAutoGenerateModel(File(getAutoGeneratedModelPath(item.namespace, item.id)), item, model)
                    for (i in 0..2)
                        generateAutoGenerateModel(
                            File(getAutoGeneratedModelPath(item.namespace, "${item.id}_$i")),
                            item,
                            model
                        )
                }
                item.material.equals("shield", ignoreCase = true) -> {

                    generateMinecraftShieldModel(minecraftModelFile, item, model)

                }
                else -> {
                    generateMinecraftModel(minecraftModelFile, item, model)
                    generateAutoGenerateModel(File(getAutoGeneratedModelPath(item.namespace, item.id)), item, model)
                }
            }


        }
    }


    private fun String.toEmpireBool(): Boolean {
        return try {
            val int = Integer.parseInt(this)
            int == 1
        } catch (e: NumberFormatException) {
            false
        }
    }

    val map: Map<Instrument, String> = mapOf(
        Instrument.BANJO to Instrument.BANJO.name.lowercase(),
        Instrument.BASS_DRUM to "basedrum",
        Instrument.BASS_GUITAR to "bass",
        Instrument.BELL to Instrument.BELL.name.lowercase(),
        Instrument.BIT to Instrument.BIT.name.lowercase(),
        Instrument.CHIME to Instrument.CHIME.name.lowercase(),
        Instrument.COW_BELL to Instrument.COW_BELL.name.lowercase(),
        Instrument.DIDGERIDOO to Instrument.DIDGERIDOO.name.lowercase(),
        Instrument.FLUTE to Instrument.FLUTE.name.lowercase(),
        Instrument.GUITAR to "bass",
        Instrument.IRON_XYLOPHONE to Instrument.IRON_XYLOPHONE.name.lowercase(),
        Instrument.PIANO to "harp",
        Instrument.PLING to Instrument.PLING.name.lowercase(),
        Instrument.SNARE_DRUM to "snare",
        Instrument.STICKS to "hat",
        Instrument.XYLOPHONE to Instrument.XYLOPHONE.name.lowercase()
    )

    private data class MushroomBlockClassJson(val multipart: MutableList<MushroomBlockApi.Multipart>)

    private fun clearBlockStates() {
        fun getMultiparts(block: String): MutableList<MushroomBlockApi.Multipart> {
            val list = mutableListOf<MushroomBlockApi.Multipart>()
            for (i in 0..63) {
                val multipart = MushroomBlockApi.getFacingByData(i)
                multipart.apply = MushroomBlockApi.Apply("block/original/${block}_true")
                list.add(multipart)
            }
            return list
        }
        File(getMinecraftPath() + "blockstates").mkdir()
        for (blockName in listOf<String>("brown_mushroom_block", "mushroom_stem", "red_mushroom_block"))
            File(getMinecraftPath() + "blockstates" + File.separator + "${blockName}.json").writeText(
                setPrettyString(Gson().toJson(MushroomBlockClassJson(getMultiparts(blockName))))
            )
    }

    private fun generateBlocks() {
        clearBlockStates()



        for (item in EmpirePlugin.empireItems.itemsInfo) {
            val id = item.id
            val empireBlock = EmpirePlugin.empireItems.empireBlocks[id] ?: continue
            val multipart = MushroomBlockApi.getFacingByData(empireBlock.data) ?: continue
            multipart.apply = MushroomBlockApi.Apply("${item.namespace}:${item.modelPath ?: "auto_generated/${id}"}")


            val materialName = MushroomBlockApi.getMaterialByData(empireBlock.data).name.lowercase()
            val file = File(getMinecraftPath() + "blockstates" + File.separator + "${materialName}.json")
            val multipartList = Gson().fromJson(JsonParser().parse(file.reader()).asJsonObject,MushroomBlockClassJson::class.java)
            println(MushroomBlockApi.Multipart(multipart.facing,MushroomBlockApi.Apply("block/original/${materialName}_true")))
            multipartList.multipart.remove(MushroomBlockApi.Multipart(multipart.facing,MushroomBlockApi.Apply("block/original/${materialName}_true")))
            multipartList.multipart.add(multipart)
            file.writeText(setPrettyString(Gson().toJson(multipartList)))

        }


    }

    private fun fixCustomModelDataOrder() {
        for (file in File(getMinecraftItemModelsPath()).listFiles()) {
            if ("json" !in file.extension)
                continue
            val jsonFile = JsonParser().parse(file.reader()).asJsonObject
            val model = Gson().fromJson(jsonFile, Model::class.java)
            model.sort()
            file.writeText(setPrettyString(Gson().toJson(model)))
        }
    }

    init {
        println(EmpirePlugin.translations.ZIP_ITEMS)
        clearItems()
        generateItems()
        println(EmpirePlugin.translations.ZIP_FONTS)
        generateFont()
        println(EmpirePlugin.translations.ZIP_SOUND)
        generateSounds()
        fixCustomModelDataOrder()
        generateBlocks()
        println(EmpirePlugin.translations.ZIP_BLOCKS)
    }


    companion object {


        fun zipAll(folderPath: String, outputFilePath: String): Boolean {
            val fos = FileOutputStream(outputFilePath)
            val zipOut = ZipOutputStream(fos)
            try {
                var fileToZip = File(folderPath + File.separator + "assets")
                zipFile(fileToZip, fileToZip.name, zipOut)
                fileToZip = File(folderPath + File.separator + "pack.mcmeta")
                zipFile(fileToZip, fileToZip.name, zipOut)
                fileToZip = File(folderPath + File.separator + "pack.png")
                zipFile(fileToZip, fileToZip.name, zipOut)

                zipOut.close()
                fos.close()
                return true
            } catch (e: IOException) {
                return false
            } finally {
                zipOut.close()
                fos.close()
            }
        }

        @Throws(IOException::class)
        private fun zipFile(
            fileToZip: File,
            fileName: String,
            zipOut: ZipOutputStream
        ) {
            if (fileToZip.isHidden) {
                return
            }
            if (fileToZip.isDirectory) {
                if (fileName.endsWith("/")) {
                    zipOut.putNextEntry(ZipEntry(fileName))
                    zipOut.closeEntry()
                } else {
                    zipOut.putNextEntry(ZipEntry("$fileName/"))
                    zipOut.closeEntry()
                }
                val children = fileToZip.listFiles()
                for (childFile in children) {
                    zipFile(childFile, fileName + "/" + childFile.name, zipOut)
                }
                return
            }
            val fis = FileInputStream(fileToZip)
            val zipEntry = ZipEntry(fileName)
            zipOut.putNextEntry(zipEntry)
            val bytes = ByteArray(1024)
            var length: Int
            while (fis.read(bytes).also { length = it } >= 0) {
                zipOut.write(bytes, 0, length)
            }
            fis.close()

        }
    }
}