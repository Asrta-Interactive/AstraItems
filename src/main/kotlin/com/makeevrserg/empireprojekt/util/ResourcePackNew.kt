package com.makeevrserg.empireprojekt.util

import com.google.gson.*
import com.google.gson.annotations.Expose
import com.google.gson.annotations.SerializedName
import com.makeevrserg.empireprojekt.EmpirePlugin
import com.makeevrserg.empireprojekt.items.EmpireItem
import org.apache.commons.lang.StringEscapeUtils
import org.bukkit.Material
import java.io.*
import java.lang.NumberFormatException
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream


class ResourcePackNew {

    private val plugin = EmpirePlugin.instance
    private fun setPrettyString(file: JsonObject): String {
        return GsonBuilder().setPrettyPrinting().create().toJson(file)
    }

    private fun setPrettyString(line: String): String {
        val file = JsonParser().parse(line).asJsonObject
        return setPrettyString(file)
    }

    private fun getMinecraftItemModelsPath(): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + "minecraft" +
                File.separator + "models" +
                File.separator + "item"
    }

    private fun getMinecraftPath(): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + "minecraft" + File.separator
    }

    private fun getMinecraftBlockModelsPath(): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + "minecraft" +
                File.separator + "models" +
                File.separator + "block" + File.separator
    }

    private fun getMinecraftItemModelPath(material: String): String {
        return getMinecraftItemModelsPath() + File.separator + material.lowercase() + ".json"
    }

    private fun getAutoGeneratedModelPath(namespace: String, item: String): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + namespace +
                File.separator + "models" +
                File.separator + "auto_generated" +
                File.separator + item + ".json"
    }

    private fun getAutoGeneratedModelsPath(namespace: String): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + namespace +
                File.separator + "models" +
                File.separator + "auto_generated"
    }

    data class Provider(
        val type: String?,
        val file: String,
        val shift: List<Double>?,
        val size: Double?,
        val oversample: Int?,
        val chars: List<String>?,
        val height: Int?,
        val ascent: Int?
    )

    data class Fonts(
        val providers: List<Provider>
    )

    private fun generateFont() {
        val file =
            File(plugin.dataFolder.toString() + File.separator + "pack" + File.separator + "assets" + File.separator + "minecraft" + File.separator + "font" + File.separator + "default.json")
        val providers: MutableList<Provider> = mutableListOf()
        val defaultJson =
            JsonParser().parse(InputStreamReader(plugin.getResource("rpFiles/default.json")!!).readText()).asJsonObject
        providers.add(Gson().fromJson(defaultJson, Fonts::class.java).providers[0])
        for (font in EmpirePlugin.empireFontImages.fontsInfo.keys) {
            val fontInfo = EmpirePlugin.empireFontImages.fontsInfo[font]!!
            val provider = Provider(
                "bitmap",
                "${fontInfo.namespace}:${fontInfo.path}",
                null, null, null,
                listOf(StringEscapeUtils.escapeJava(fontInfo.chars)),
                fontInfo.height, fontInfo.ascent
            )
            providers.add(provider)
        }
        val json = Gson().toJson(Fonts(providers))
        file.writeText(setPrettyString(JsonParser().parse(json).asJsonObject).replace("\\\\", "\\"))
    }

    private fun generateSounds() {
        val map = EmpirePlugin.empireSounds.getSounds()
        val namespace = EmpirePlugin.empireSounds.getNamespace()
        val file = File(
            plugin.dataFolder,
            "pack${File.separator}assets${File.separator}${namespace}${File.separator}sounds.json"
        )
        val musicFileObj = JsonObject()
        for (soundID in map.keys) {
            val musicObj = JsonObject()
            val sounds = JsonArray()
            for (sound in map[soundID]!!)
                sounds.add("$namespace:$sound")
            musicObj.add("sounds", sounds)
            musicFileObj.add(soundID, musicObj)
        }
        file.writeText(setPrettyString(musicFileObj))
    }


    data class Model(
        var parent: String,
        var textures: Textures,
        var overrides: MutableList<Override>?,
        var gui_light: String?,
        var display: JsonObject?
    ) {
        public fun sort() {
            overrides ?: return
            overrides?.sortBy { it.predicate.custom_model_data }
        }
    }

    data class Override(
        val model: String,
        val predicate: Predicate
    )

    data class Predicate(

        val custom_model_data: Int,
        val blocking: Int?,
        val pulling: Int?,
        val pull: Double?
    )

    data class Textures(
        var layer0: String?,
        var all: String?,
        var particle: String?
    )


    private fun clearItems() {
        for (file in File(getMinecraftItemModelsPath()).listFiles()) {
            if ("json" !in file.extension)
                continue
            if (file.name.contains("bow") || file.name.contains("shield")) {
                file.delete()
                continue
            }
            val jsonFile = JsonParser().parse(file.reader()).asJsonObject
            jsonFile.remove("overrides")
            file.writeText(setPrettyString(jsonFile))
        }
        File(getMinecraftItemModelPath("bow")).writeText(InputStreamReader(plugin.getResource("rpFiles/bow.json")!!).readText())
        File(getMinecraftItemModelPath("shield")).writeText(InputStreamReader(plugin.getResource("rpFiles/shield.json")!!).readText())
        File(getMinecraftItemModelPath("shield_blocking")).writeText(InputStreamReader(plugin.getResource("rpFiles/shield.json")!!).readText())
    }


    private fun generateMinecraftModel(file: File, item: EmpireItem, model: Model) {
        val predicate = Predicate(item.customModelData, null, null, null)
        val override = Override("${item.namespace}:${item.modelPath ?: ("auto_generated/" + item.id)}", predicate)
        model.overrides!!.add(override)
        file.writeText(setPrettyString(Gson().toJson(model)))
    }

    private fun generateMinecraftBowModel(file: File, item: EmpireItem, model: Model) {
        model.overrides!!.add(
            Override(
                "${item.namespace}:auto_generated/${item.id}",
                Predicate(item.customModelData, null, 0, null)
            )
        )
        model.overrides!!.add(
            Override(
                "${item.namespace}:auto_generated/${item.id}_0",
                Predicate(item.customModelData, null, 1, null)
            )
        )
        model.overrides!!.add(
            Override(
                "${item.namespace}:auto_generated/${item.id}_1",
                Predicate(item.customModelData, null, 1, 0.65)
            )
        )
        model.overrides!!.add(
            Override(
                "${item.namespace}:auto_generated/${item.id}_2",
                Predicate(item.customModelData, null, 1, 0.9)
            )
        )

        file.writeText(setPrettyString(Gson().toJson(model)))
    }

    private fun generateMinecraftShieldModel(file: File, item: EmpireItem, model: Model) {
        for (i in 0..1)
            model.overrides!!.add(
                Override(
                    "${item.namespace}:${item.modelPath ?: ("auto_generated/" + item.id)}",
                    Predicate(item.customModelData, i, null, null)
                )
            )
        file.writeText(setPrettyString(Gson().toJson(model)))
    }

    private fun generateAutoGenerateModel(file: File, item: EmpireItem, model: Model) {
        if (!file.exists())
            file.createNewFile()
        model.overrides = null
        model.display = null
        model.gui_light = null
        if (item.material.name.equals("bow", ignoreCase = true)) {
            model.parent = "item/base/bow"
            try {
                val code = file.nameWithoutExtension[file.nameWithoutExtension.length - 1].toString().toInt()
                model.textures.layer0 = "${item.namespace}:${item.texturePath}_${code}"
            } catch (e: NumberFormatException) {
                model.textures.layer0 = "${item.namespace}:${item.texturePath}"
            }
        } else if (item.empireBlock != null) {
            model.parent = "block/base/block_real"
            model.textures = Textures(null, null, null)
            model.textures.all = "${item.namespace}:${item.texturePath}"
            model.textures.particle = "${item.namespace}:${item.texturePath}"
        } else
            model.textures.layer0 = "${item.namespace}:${item.texturePath}"
        file.writeText(setPrettyString(Gson().toJson(model)))
    }


    private fun generateItems() {
        val items = EmpirePlugin.empireItems.itemsInfo
        for (item in items) {
            val filePath = getMinecraftItemModelPath(item.material.name)
            val minecraftModelFile = File(filePath)
            if (!minecraftModelFile.exists()) {
                println(EmpirePlugin.translations.NOT_EXIST_FILE + " ${item.material.name.lowercase()}.json")
                continue
            }
            val fileText = InputStreamReader(minecraftModelFile.inputStream()).readText()
            val jsonObject = JsonParser().parse(fileText).asJsonObject
            val model: Model = Gson().fromJson(jsonObject, Model::class.java)
            if (model.overrides == null)
                model.overrides = mutableListOf()
            when {
                item.material.name.equals("bow", ignoreCase = true) -> {
                    generateMinecraftBowModel(minecraftModelFile, item, model)
                    generateAutoGenerateModel(File(getAutoGeneratedModelPath(item.namespace, item.id)), item, model)
                    for (i in 0..2)
                        generateAutoGenerateModel(
                            File(getAutoGeneratedModelPath(item.namespace, "${item.id}_$i")),
                            item,
                            model
                        )
                }
                item.material.name.equals("shield", ignoreCase = true) -> {

                    generateMinecraftShieldModel(minecraftModelFile, item, model)

                }
                else -> {
                    generateMinecraftModel(minecraftModelFile, item, model)
                    generateAutoGenerateModel(File(getAutoGeneratedModelPath(item.namespace, item.id)), item, model)
                }
            }


        }
    }

    data class BlockJson(
        val multipart: List<Multipart>?
    )

    data class Multipart(
        @SerializedName("when")
        val _when: When? = When(),
        val apply: Apply?
    )

    data class Apply(
        val model: String
    )


    data class When(
        var down: Boolean = false,
        var east: Boolean = false,
        var north: Boolean = false,
        var south: Boolean = false,
        var up: Boolean = false,
        var west: Boolean = false

    ) {
        private fun String.toEmpireBool(): Boolean {
            return try {
                val int = Integer.parseInt(this)
                int == 1
            } catch (e: NumberFormatException) {
                false
            }

        }

        public fun set(index: Int, value: Boolean) {
            when (index) {
                0 -> down = value
                1 -> east = value
                2 -> north = value
                3 -> south = value
                4 -> up = value
                5 -> west = value
            }
        }

        public fun set(index: Int, value: String) {
            val bool = value.toEmpireBool()
            when (index) {
                0 -> down = bool
                1 -> east = bool
                2 -> north = bool
                3 -> south = bool
                4 -> up = bool
                5 -> west = bool
            }
        }
    }

    private fun String.toEmpireBool(): Boolean {
        return try {
            val int = Integer.parseInt(this)
            int == 1
        } catch (e: NumberFormatException) {
            false
        }
    }


    private fun generateBlocks() {

        //File(getMinecraftBlockModelsPath()).writeText(InputStreamReader(plugin.getResource("block/base/block_real.json")!!).readText())

        val items = EmpirePlugin.empireItems.itemsInfo

        File(getMinecraftPath() + "blockstates").mkdir()
        val file = File(getMinecraftPath() + "blockstates" + File.separator + "brown_mushroom_block.json")

        val whenList = mutableListOf<Multipart>()
        val dataList = mutableListOf<Int>()
        for (item in items) {
            item.empireBlock?.data ?: continue
            val filePath = getMinecraftItemModelPath(item.material.name)
            val minecraftModelFile = File(filePath)
            if (!minecraftModelFile.exists()) {
                println(EmpirePlugin.translations.NOT_EXIST_FILE + " ${item.material.name.lowercase()}.json")
                continue
            }
            val fileText = InputStreamReader(minecraftModelFile.inputStream()).readText()
            val jsonObject = JsonParser().parse(fileText).asJsonObject
            val model: Model = Gson().fromJson(jsonObject, Model::class.java)
            val _when = generateStateByData(item.empireBlock.data)
            val multipart = Multipart(_when, Apply("${item.namespace}:${item.modelPath?:"auto_generated/"+item.id}"))
            whenList.add(multipart)
            dataList.add(item.empireBlock.data)
        }
        for (i in 0..63)
            if (!dataList.contains(i)) {
                val _when = generateStateByData(i)
                val multipart = Multipart(_when, Apply("block/original/brown_mushroom_block_true"))
                whenList.add(multipart)
            }

        val blockJson = BlockJson(whenList)
        val json = Gson().toJson(blockJson)
        file.createNewFile()
        file.writeText(setPrettyString(json))
    }

    private fun fixCustomModelDataOrder() {
        for (file in File(getMinecraftItemModelsPath()).listFiles()) {
            if ("json" !in file.extension)
                continue
            val jsonFile = JsonParser().parse(file.reader()).asJsonObject
            val model = Gson().fromJson(jsonFile, Model::class.java)
            model.sort()
            file.writeText(setPrettyString(Gson().toJson(model)))
        }
    }

    init {
        println(EmpirePlugin.translations.ZIP_ITEMS)
        clearItems()
        generateItems()
        println(EmpirePlugin.translations.ZIP_FONTS)
        generateFont()
        println(EmpirePlugin.translations.ZIP_SOUND)
        generateSounds()
        fixCustomModelDataOrder()
        generateBlocks()
        println(EmpirePlugin.translations.ZIP_BLOCKS)
    }


    companion object {
        public fun generateStateByData(d: Int): When {
            val _when = When()
            var data = d
            if (data >= 64) {
                data -= 64
            }
            val byteString = Integer.toBinaryString(data)
            for (index in byteString.indices)
                _when.set(5 - index, byteString[byteString.length - 1 - index].toString())
            return _when
        }

        private fun Boolean.toInt(): Int {
            return if (this) 1 else 0

        }

        public fun generateDataByState(state: When): Int {
            val int =
                "${state.down.toInt()}${state.east.toInt()}${state.north.toInt()}${state.south.toInt()}${state.up.toInt()}${state.west.toInt()}"
            return try {
                Integer.parseInt(int, 2)
            } catch (e: NumberFormatException) {
                -1
            }

        }

        fun zipAll(folderPath: String, outputFilePath: String): Boolean {
            val fos = FileOutputStream(outputFilePath)
            val zipOut = ZipOutputStream(fos)
            try {
                var fileToZip = File(folderPath + File.separator + "assets")
                zipFile(fileToZip, fileToZip.name, zipOut)
                fileToZip = File(folderPath + File.separator + "pack.mcmeta")
                zipFile(fileToZip, fileToZip.name, zipOut)
                fileToZip = File(folderPath + File.separator + "pack.png")
                zipFile(fileToZip, fileToZip.name, zipOut)

                zipOut.close()
                fos.close()
                return true
            } catch (e: IOException) {
                return false
            } finally {
                zipOut.close()
                fos.close()
            }
        }

        @Throws(IOException::class)
        private fun zipFile(
            fileToZip: File,
            fileName: String,
            zipOut: ZipOutputStream
        ) {
            if (fileToZip.isHidden) {
                return
            }
            if (fileToZip.isDirectory) {
                if (fileName.endsWith("/")) {
                    zipOut.putNextEntry(ZipEntry(fileName))
                    zipOut.closeEntry()
                } else {
                    zipOut.putNextEntry(ZipEntry("$fileName/"))
                    zipOut.closeEntry()
                }
                val children = fileToZip.listFiles()
                for (childFile in children) {
                    zipFile(childFile, fileName + "/" + childFile.name, zipOut)
                }
                return
            }
            val fis = FileInputStream(fileToZip)
            val zipEntry = ZipEntry(fileName)
            zipOut.putNextEntry(zipEntry)
            val bytes = ByteArray(1024)
            var length: Int
            while (fis.read(bytes).also { length = it } >= 0) {
                zipOut.write(bytes, 0, length)
            }
            fis.close()

        }
    }
}