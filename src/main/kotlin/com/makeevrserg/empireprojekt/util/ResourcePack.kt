package com.makeevrserg.empireprojekt.util

import com.google.gson.GsonBuilder
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import com.makeevrserg.empireprojekt.EmpirePlugin
import com.makeevrserg.empireprojekt.items.EmpireItems
import org.apache.commons.lang.StringEscapeUtils
import org.bukkit.Material
import java.io.*
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream


class ResourcePack {

    private val plugin = EmpirePlugin.instance
    private fun setPrettyString(file: JsonObject): String {
        return GsonBuilder().setPrettyPrinting().create().toJson(file)
    }

    private fun getMinecraftModelsPath(): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + "minecraft" +
                File.separator + "models" +
                File.separator + "item"
    }

    private fun getMinecraftModelPath(material: String): String {
        return getMinecraftModelsPath() + File.separator + material.toLowerCase() + ".json"
    }

    private fun getAutoGeneratedModelsPath(namespace: String): String {
        return plugin.dataFolder.toString() +
                File.separator + "pack" +
                File.separator + "assets" +
                File.separator + namespace +
                File.separator + "models" +
                File.separator + "auto_generated"
    }

    private fun generateItems(itemsInfo: List<EmpireItems.ItemInfo>) {
        fun addModelProperty(jsonObject: JsonObject, namespace: String, id: String?, modelPath: String?) {
            if (modelPath == null)
                jsonObject.addProperty("model", "$namespace:auto_generated/$id")
            else
                jsonObject.addProperty("model", "$namespace:$modelPath")
        }

        fun addCustomModelData(jsonObject: JsonObject, customModelData: Int) {
            jsonObject.addProperty("custom_model_data", customModelData)
        }

        fun getParent(itemInfo: EmpireItems.ItemInfo): String {
            val minecraftModelsPath =
                getMinecraftModelsPath() + File.separator + itemInfo.material.toLowerCase() + ".json"
            return JsonParser().parse(File(minecraftModelsPath).reader()).asJsonObject.get("parent").asString

        }

        fun generateMinecraftStandartModel(itemInfo: EmpireItems.ItemInfo) {
            val minecraftModelPath = getMinecraftModelPath(itemInfo.material)
            if (!File(minecraftModelPath).exists()) {
                println("${EmpirePlugin.translations.NOT_EXIST_FILE} ${itemInfo.material.toLowerCase()}")
                return
            }
            val mModelJsonObject =
                JsonParser().parse(File(minecraftModelPath).reader()).asJsonObject

            val mItemJsonObject = JsonObject()
            addModelProperty(mItemJsonObject, itemInfo.namespace, itemInfo.id, itemInfo.model_path)
            val jsonPredicate = JsonObject()
            addCustomModelData(jsonPredicate, itemInfo.customModelData)
            mItemJsonObject.add("predicate", jsonPredicate)


            val mModelJsonArray = mModelJsonObject.getAsJsonArray("overrides") ?: JsonArray()
            mModelJsonArray.add(mItemJsonObject)
            mModelJsonObject.add("overrides", mModelJsonArray)
            File(minecraftModelPath).writeText(
                setPrettyString(mModelJsonObject)
            )
        }

        fun getAutoGeneratedModelPath(namespace: String, id: String): String {
            return getAutoGeneratedModelsPath(namespace) + File.separator + id + ".json"
        }

        fun generateEmpireStandartModel(itemInfo: EmpireItems.ItemInfo) {
            val autoGeneratedModelsPath = getAutoGeneratedModelPath(itemInfo.namespace, itemInfo.id)
            val file = File(autoGeneratedModelsPath)
            if (!file.exists())
                file.createNewFile()
            val aModelJsonObject = JsonObject()
            aModelJsonObject.addProperty("parent", getParent(itemInfo))
            val jsonObject = JsonObject()
            jsonObject.addProperty("layer0", "${itemInfo.namespace}:${itemInfo.texture_path ?: return}")
            aModelJsonObject.add("textures", jsonObject)
            file.writeText(setPrettyString(aModelJsonObject))
        }

        fun getBowOverride(id: String, pulling: Int, customModelData: Int, namespace: String): JsonObject {
            val bowJson = JsonObject()
            val predicateJson = JsonObject()
            if (id.contains("_1"))
                predicateJson.addProperty("pull", 0.65)
            if (id.contains("_2"))
                predicateJson.addProperty("pull", 0.9)
            addCustomModelData(predicateJson, customModelData)
            predicateJson.addProperty("pulling", pulling)
            bowJson.add("predicate", predicateJson)

            addModelProperty(bowJson, namespace, id, null)
            return bowJson

        }

        fun generateMinecraftBowModel(itemInfo: EmpireItems.ItemInfo) {
            val mincraftModelFile = File(getMinecraftModelPath(itemInfo.material))
            if (!mincraftModelFile.exists())
                mincraftModelFile.writeText(InputStreamReader(plugin.getResource("rpFiles/bow.json")!!).readText())
            val bowObject = JsonParser().parse(mincraftModelFile.reader()).asJsonObject
            val overrides = bowObject.getAsJsonArray("overrides")
            overrides.add(getBowOverride(itemInfo.id, 0, itemInfo.customModelData, itemInfo.namespace))
            overrides.add(getBowOverride(itemInfo.id + "_0", 1, itemInfo.customModelData, itemInfo.namespace))
            overrides.add(getBowOverride(itemInfo.id + "_1", 1, itemInfo.customModelData, itemInfo.namespace))
            overrides.add(getBowOverride(itemInfo.id + "_2", 1, itemInfo.customModelData, itemInfo.namespace))
            bowObject.add("overrides", overrides)
            mincraftModelFile.writeText(setPrettyString(bowObject))
        }

        fun generateEmpireBowModel(filePath: String, itemPath: String) {
            val file = File(filePath)
            val jsonObject = JsonObject()
            jsonObject.addProperty("parent", "item/base/bow")
            val jsonTextures = JsonObject()
            jsonTextures.addProperty("layer0", itemPath)
            jsonObject.add("textures", jsonTextures)
            file.writeText(setPrettyString(jsonObject))

        }


        fun getShieldObject(itemInfo: EmpireItems.ItemInfo, blocking: Int): JsonObject {

            val override = JsonObject()
            addModelProperty(override, itemInfo.namespace, itemInfo.id, itemInfo.model_path)
            val predicate = JsonObject()
            predicate.addProperty("blocking", blocking)
            addCustomModelData(predicate, itemInfo.customModelData)
            override.add("predicate", predicate)
            return override

        }


        fun generateMinecraftShield(itemInfo: EmpireItems.ItemInfo) {
            val file = File(getMinecraftModelPath(itemInfo.material))
            if (!file.exists()) {
                file.writeText(InputStreamReader(plugin.getResource("rpFiles/shield.json")!!).readText())
                File(getMinecraftModelPath(itemInfo.material + "_blocking")).writeText(
                    InputStreamReader(
                        plugin.getResource(
                            "rpFiles/shield_blocking.json"
                        )!!
                    ).readText()
                )
            }
            val shieldObject = JsonParser().parse(file.readText()).asJsonObject
            val overrides = shieldObject.getAsJsonArray("overrides")
            overrides.add(getShieldObject(itemInfo, 0))
            overrides.add(getShieldObject(itemInfo, 1))
            shieldObject.add("overrides", overrides)
            file.writeText(setPrettyString(shieldObject))
        }
        for (itemInfo: EmpireItems.ItemInfo in itemsInfo) {
            if (itemInfo.material.equals(Material.BOW.name, ignoreCase = true)) {
                generateMinecraftBowModel(itemInfo)
                generateEmpireBowModel(
                    getAutoGeneratedModelPath(itemInfo.namespace, itemInfo.id),
                    itemInfo.namespace + ":" + itemInfo.texture_path!!
                )
                generateEmpireBowModel(
                    getAutoGeneratedModelPath(itemInfo.namespace, itemInfo.id + "_0"),
                    itemInfo.namespace + ":" + itemInfo.texture_path!! + "_0"
                )
                generateEmpireBowModel(
                    getAutoGeneratedModelPath(itemInfo.namespace, itemInfo.id + "_1"),
                    itemInfo.namespace + ":" + itemInfo.texture_path!! + "_1"
                )
                generateEmpireBowModel(
                    getAutoGeneratedModelPath(itemInfo.namespace, itemInfo.id + "_2"),
                    itemInfo.namespace + ":" + itemInfo.texture_path!! + "_2"
                )
            } else if (itemInfo.material.equals(Material.SHIELD.name, ignoreCase = true)) {
                generateMinecraftShield(itemInfo)
            } else {
                if (itemInfo.texture_path == null) {
                    generateMinecraftStandartModel(itemInfo)
                    continue
                }
                generateEmpireStandartModel(itemInfo)
                generateMinecraftStandartModel(itemInfo)
            }

        }
    }

    private fun clearItems() {
        val minecraftModelsPath: String = getMinecraftModelsPath()

        for (file in File(minecraftModelsPath).listFiles()) {
            if ("json" !in file.extension)
                continue
            if (file.name.contains("bow") || file.name.contains("shield")) {
                file.delete()
                continue
            }
            val jsonFile = JsonParser().parse(file.reader()).asJsonObject
            jsonFile.remove("overrides")
            file.writeText(setPrettyString(jsonFile))

        }

        val defaultFontFile =
            File(plugin.dataFolder.toString() + File.separator + "pack" + File.separator + "assets" + File.separator + "minecraft" + File.separator + "font" + File.separator + "default.json")
        defaultFontFile.writeText(InputStreamReader(plugin.getResource("rpFiles/default.json")!!).readText())
    }


    private fun generateFont() {
        val file =
            File(plugin.dataFolder.toString() + File.separator + "pack" + File.separator + "assets" + File.separator + "minecraft" + File.separator + "font" + File.separator + "default.json")


        val defaultJson = JsonParser().parse(file.reader()).asJsonObject
        val defaultJsonArray = defaultJson.getAsJsonArray("providers")
        for (font in EmpirePlugin.empireFontImages.fontsInfo.keys) {
            val jsonFont = JsonObject()
            val fontInfo = EmpirePlugin.empireFontImages.fontsInfo[font]!!
            jsonFont.addProperty("file", "${fontInfo.namespace}:${fontInfo.path}")
            val tempArray = JsonArray()

            tempArray.add(StringEscapeUtils.escapeJava(fontInfo.chars))
            jsonFont.add("chars", tempArray)
            jsonFont.addProperty("height", fontInfo.offset)
            jsonFont.addProperty("ascent", fontInfo.size)
            jsonFont.addProperty("type", "bitmap")
            defaultJsonArray.add(jsonFont)
        }
        defaultJson.add("providers", defaultJsonArray)

        file.writeText(setPrettyString(defaultJson).replace("\\\\", "\\"))
    }

    private fun generateSounds() {
        val map = EmpirePlugin.empireSounds.getSounds()
        val namespace = EmpirePlugin.empireSounds.getNamespace()
        val file = File(
            plugin.dataFolder,
            "pack${File.separator}assets${File.separator}${namespace}${File.separator}sounds.json"
        )
        val musicFileObj = JsonObject()
        for (soundID in map.keys) {
            val musicObj = JsonObject()
            val sounds = JsonArray()
            for (sound in map[soundID]!!)
                sounds.add("$namespace:$sound")
            musicObj.add("sounds", sounds)
            musicFileObj.add(soundID, musicObj)
        }
        file.writeText(setPrettyString(musicFileObj))
    }


//    fun fixCustomModelDataOrder() {
//        val files = getFilesList()
//
//        if (files != null) {
//            Arrays.sort(files)
//            for (file in files)
//                if (isJson(file)) {
//                    val defaultJson = JsonParser().parse(file.reader()).asJsonObject
//                    val overridesArray = defaultJson.getAsJsonArray("overrides")
//                    val predicates = mutableMapOf<String,JsonObject>()
//                    for (i in 0 until overridesArray.size()){
//                        val jObj = overridesArray.get(i).asJsonObject
//                        if (jObj.has("predicate")){
//                            val predicate = jObj.getAsJsonObject("predicate")
//                            if (predicate.has("custom_model_data")) {
//                                predicates[predicate.get("custom_model_data").asString] = jObj
//                                overridesArray
//                            }
//                        }
//                    }
//                }
//        }
//    }

    init {
        println(EmpirePlugin.translations.ZIP_ITEMS)
        clearItems()
        generateItems(EmpirePlugin.empireItems.itemsInfo)
        println(EmpirePlugin.translations.ZIP_FONTS)
        generateFont()
        println(EmpirePlugin.translations.ZIP_SOUND)
        generateSounds()
        //fixCustomModelDataOrder()
    }


    companion object {

        fun zipAll(folderPath: String, outputFilePath: String): Boolean {
            val fos = FileOutputStream(outputFilePath)
            val zipOut = ZipOutputStream(fos)
            try {
                var fileToZip = File(folderPath + File.separator + "assets")
                zipFile(fileToZip, fileToZip.name, zipOut)
                fileToZip = File(folderPath + File.separator + "pack.mcmeta")
                zipFile(fileToZip, fileToZip.name, zipOut)
                fileToZip = File(folderPath + File.separator + "pack.png")
                zipFile(fileToZip, fileToZip.name, zipOut)

                zipOut.close()
                fos.close()
                return true
            } catch (e: IOException) {
                return false
            } finally {
                zipOut.close()
                fos.close()
            }
        }

        @Throws(IOException::class)
        private fun zipFile(
            fileToZip: File,
            fileName: String,
            zipOut: ZipOutputStream
        ) {
            if (fileToZip.isHidden) {
                return
            }
            if (fileToZip.isDirectory) {
                if (fileName.endsWith("/")) {
                    zipOut.putNextEntry(ZipEntry(fileName))
                    zipOut.closeEntry()
                } else {
                    zipOut.putNextEntry(ZipEntry("$fileName/"))
                    zipOut.closeEntry()
                }
                val children = fileToZip.listFiles()
                for (childFile in children) {
                    zipFile(childFile, fileName + "/" + childFile.name, zipOut)
                }
                return
            }
            val fis = FileInputStream(fileToZip)
            val zipEntry = ZipEntry(fileName)
            zipOut.putNextEntry(zipEntry)
            val bytes = ByteArray(1024)
            var length: Int
            while (fis.read(bytes).also { length = it } >= 0) {
                zipOut.write(bytes, 0, length)
            }
            fis.close()

        }
    }
}